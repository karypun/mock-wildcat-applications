"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCompletionContext = exports.CompletionContext = exports.Completion = void 0;
const react_1 = require("react");
const graph_1 = require("./graph");
const helpers_1 = require("./helpers");
const calculateNext = (fields, fieldStatus, errors) => {
    const reducer = (acc, cur) => (acc === undefined
        ? (((fieldStatus[cur].seen === false && fieldStatus[cur].visible === false) || errors[cur] !== undefined)
            ? cur
            : undefined)
        : acc);
    return fields.reduce(reducer, undefined);
};
class Completion {
    constructor(graph) {
        this.graph = graph;
        this.path = [];
        this.fields = {};
        this.fieldsInScope = [];
        this.nextItem = 0;
    }
    initialise(values, touched) {
        this.graph.deepMap_(e => e.depopulate());
        this.graph.gatherAllFieldNodes()
            .map(e => this.fields[e.name] = {
            inScope: false,
            visible: false,
            seen: !!touched[e.name],
            preValidate: e.preValidate,
            validate: e.validate,
            format: e.format
        });
        this.updateScope(values);
        Object.keys(this.fields).map(e => values[e] = values[e] || null);
    }
    updateScope(values) {
        this.graph.deepMap_(e => e.depopulate());
        this.graph.deepMap_(e => e.populateFromValues(values));
        this.fieldsInScope = this.graph
            .gatherFieldsAlongPath(values);
        Object.keys(this.fields).map(e => this.fields[e].inScope = false);
        this.fieldsInScope.map(e => this.fields[e].inScope = true);
    }
    update(values, errors) {
        const next = calculateNext(this.fieldsInScope, this.fields, errors);
        this.graph.deepMap_(e => e.populateFromNext(next));
        const visibleFields = this.graph.gatherFieldsAlongPath(values);
        Object.keys(this.fields).map(e => this.fields[e].seen = this.fields[e].seen || this.fields[e].visible);
        Object.keys(this.fields).map(e => this.fields[e].visible = false);
        visibleFields.map(e => this.fields[e].visible = true);
        this.path = this.graph.toPath(values, next);
        this.nextItem = 0;
    }
    formatFields(values) {
        const r = {};
        Object.keys(this.fields)
            .map(e => {
            const field = this.fields[e];
            const value = values[e];
            const format = (value !== null && field.format) || helpers_1.id;
            r[e] = (field.inScope
                ? format(value)
                : undefined);
            return true;
        });
        return r;
    }
    validateFields(values, formattedValues) {
        const r = {};
        Object.keys(this.fields)
            .map(e => {
            const field = this.fields[e];
            const preValidate = field.preValidate;
            const validate = field.validate;
            const error = (preValidate && preValidate(values[e])) ||
                (validate && validate(formattedValues[e]));
            if (field.inScope && error) {
                r[e] = error;
            }
            return true;
        });
        return r;
    }
    pop() {
        const r = this.path && this.path[this.nextItem++];
        if (this.nextItem >= this.path.length) {
            this.nextItem = 0;
        }
        return r;
    }
    getUnseenFields() {
        return Object.keys(this.fields)
            .map(e => this.fields[e].seen === false && e)
            .filter(helpers_1.id);
    }
}
exports.Completion = Completion;
;
exports.CompletionContext = react_1.createContext(new Completion(new graph_1.Graph()));
exports.useCompletionContext = () => (react_1.useContext(exports.CompletionContext));
exports.default = exports.CompletionContext;
