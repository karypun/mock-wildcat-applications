"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthMethod = exports.engine = exports.NodeEnv = exports.Mode = void 0;
const apollo_server_restify_1 = require("apollo-server-restify");
const http_proxy_middleware_1 = require("http-proxy-middleware");
const serverless_http_1 = __importDefault(require("serverless-http"));
const restify_1 = __importStar(require("@not-govuk/restify"));
const server_renderer_1 = require("@not-govuk/server-renderer");
const auth_1 = require("./lib/auth");
Object.defineProperty(exports, "AuthMethod", { enumerable: true, get: function () { return auth_1.AuthMethod; } });
const pages_1 = require("./lib/pages");
var Mode;
(function (Mode) {
    Mode["Server"] = "server";
    Mode["Serverless"] = "serverless";
    Mode["StaticGenerator"] = "static-generator";
})(Mode = exports.Mode || (exports.Mode = {}));
;
var NodeEnv;
(function (NodeEnv) {
    NodeEnv["Development"] = "development";
    NodeEnv["Production"] = "production";
})(NodeEnv = exports.NodeEnv || (exports.NodeEnv = {}));
;
const isPreBuiltAssets = (v) => !!('entrypoints' in v && 'localPath' in v && 'publicPath' in v);
const isWebpackConfig = (v) => !isPreBuiltAssets(v);
exports.engine = async (options1) => {
    const webpackConfig = (options1.env === NodeEnv.Development && isWebpackConfig(options1.assets)
        ? (Array.isArray(options1.assets)
            ? options1.assets.filter(e => e.target !== 'node')[0]
            : options1.assets)
        : undefined);
    const preBuiltAssets = (isPreBuiltAssets(options1.assets)
        ? options1.assets
        : undefined);
    const publicPath = (preBuiltAssets === null || preBuiltAssets === void 0 ? void 0 : preBuiltAssets.publicPath) || webpackConfig.output.publicPath;
    const localAssetsPath = (preBuiltAssets === null || preBuiltAssets === void 0 ? void 0 : preBuiltAssets.localPath) || webpackConfig.output.path;
    const { default: webpackMiddleware } = ((webpackConfig && !options1.ssrOnly)
        ? await Promise.resolve().then(() => __importStar(require('./lib/webpack')))
        : { default: undefined });
    const webpack = webpackMiddleware && webpackMiddleware(webpackConfig);
    const port = (webpack
        ? options1.httpd.port + 1
        : options1.httpd.port);
    let proxy;
    if (webpack) {
        const httpd = restify_1.default.createServer({
            bodyParser: false,
            name: `${options1.name}-asset-proxy`
        });
        const proxyMiddleware = http_proxy_middleware_1.createProxyMiddleware({
            target: `http://localhost:${port}`,
            changeOrigin: true
        });
        const close = httpd.close.bind(httpd);
        httpd.pre(webpack.serveFiles);
        httpd.get(webpack.hotPath, webpack.hot);
        httpd.get('/*', proxyMiddleware);
        httpd.post('/*', proxyMiddleware);
        httpd.close = function (cb) {
            webpack.hot.close();
            return close(cb);
        };
        httpd.listen(options1.httpd.port, options1.httpd.host, () => {
            httpd.log.info('%s listening at %s', httpd.name, httpd.url);
        });
        proxy = httpd;
    }
    const stage2 = async (options2) => {
        const signInOut = options2.auth && !([
            auth_1.AuthMethod.None,
            auth_1.AuthMethod.Dummy,
            auth_1.AuthMethod.Headers
        ].includes(options2.auth.method));
        const signInHRef = (signInOut
            ? '/auth/sign-in'
            : undefined);
        const signOutHRef = (signInOut
            ? '/auth/sign-out'
            : undefined);
        const pages = await pages_1.gatherPages(options2.pageLoader);
        const react = server_renderer_1.reactRenderer({
            AppWrap: options2.AppWrap,
            ErrorPage: options2.ErrorPage,
            PageWrap: options2.PageWrap,
            assetsPath: publicPath,
            entrypoints: preBuiltAssets === null || preBuiltAssets === void 0 ? void 0 : preBuiltAssets.entrypoints,
            graphQL: options2.graphQL && {
                schema: options2.graphQL.schema
            },
            pages,
            rootId: 'root',
            signInHRef,
            signOutHRef,
            ssrOnly: options1.ssrOnly
        });
        const formatHTML = react.formatHTML;
        const httpd = restify_1.default.createServer({
            name: options1.name,
            formatters: {
                'application/xhtml+xml; q=0.2': formatHTML,
                'text/html; q=0.2': formatHTML
            },
        });
        httpd.use(react.renderer);
        if (options2.auth) {
            const { apply: applyAuth } = await auth_1.auth(options2.auth);
            applyAuth(httpd);
        }
        const publicPaths = publicPath + '*';
        const servePublicFiles = restify_1.default.plugins.serveStaticFiles(localAssetsPath);
        if (webpack) {
            httpd.pre(webpack.serveFiles);
        }
        httpd.head(publicPaths, servePublicFiles);
        httpd.get(publicPaths, servePublicFiles);
        httpd.serve('/', pages_1.pageRoutes(pages));
        options2.apis && options2.apis.forEach(e => (httpd.serveAPI(e.path, e.router)));
        if (options2.graphQL && !options1.ssrOnly) {
            const endpoint = '/graphql';
            const graphQLOptions = (req) => ({
                schema: options2.graphQL.schema,
                context: { auth: req.auth }
            });
            const graphQL = new restify_1.Router();
            const handler = apollo_server_restify_1.graphqlRestify(graphQLOptions);
            graphQL.post('/', handler);
            graphQL.get('/', handler);
            httpd.serveAPI(endpoint, graphQL);
            if (options1.env === NodeEnv.Development) {
                httpd.get('/graphiql', apollo_server_restify_1.graphiqlRestify({ endpointURL: endpoint }));
            }
        }
        let r;
        switch (options1.mode) {
            case Mode.Serverless:
                r = serverless_http_1.default(httpd);
                break;
            case Mode.StaticGenerator:
            case Mode.Server:
                r = httpd;
                httpd.listen(port, options1.httpd.host, () => {
                    httpd.log.info('%s listening at %s', httpd.name, httpd.url);
                });
                if (options1.mode === Mode.StaticGenerator) {
                    r = false;
                    throw new Error('WRITEME!');
                    httpd.close();
                    r = true;
                }
                break;
            default:
                throw new Error('Invalid mode');
                break;
        }
        return r;
    };
    return Object.assign(stage2, { proxy });
};
exports.default = exports.engine;
var restify_2 = require("@not-govuk/restify");
Object.defineProperty(exports, "Router", { enumerable: true, get: function () { return restify_2.Router; } });
Object.defineProperty(exports, "errors", { enumerable: true, get: function () { return restify_2.errors; } });
